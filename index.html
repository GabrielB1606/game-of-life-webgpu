<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGPU Madness</title>
</head>
<body>

    <canvas width="512" height="512"></canvas>

    <script type="module">

        // get the canvas from the HTML
        const canvas = document.querySelector("canvas");

        // make sure that the browser supports WebGPU
        if (!navigator.gpu) {
            throw new Error("WebGPU not supported on this browser.");
        }

        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
            throw new Error("No appropriate GPUAdapter found.");
        }

        // get the device (can have parameters tho)
        const device = await adapter.requestDevice();

        // make the WebGPU context
        const context = canvas.getContext("webgpu");
        const canvasFormat = navigator.gpu.getPreferredCanvasFormat();  //Texture format that the context should use
        context.configure({
            device: device,
            format: canvasFormat,
        });

        // Vertices
        const vertices = new Float32Array([
            //   X,    Y,
            -0.8, -0.8, // Triangle 1 (Blue)
             0.8, -0.8,
             0.8,  0.8,

            -0.8, -0.8, // Triangle 2 (Red)
             0.8,  0.8,
            -0.8,  0.8,
        ]);

        // VBO
        const vertexBuffer = device.createBuffer({
            label: "Cell vertices",
            size: vertices.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });

        device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/0, vertices);

        const vertexBufferLayout = {
            arrayStride: 8,
            attributes: [{
                format: "float32x2",
                offset: 0,
                shaderLocation: 0, // Position, see vertex shader
            }],
        };

        // Note: You can also create a separate shader module for your vertex and fragment shaders, if you want. That can be beneficial if, for example, you want to use several different fragment shaders with the same vertex shader.
        const cellShaderModule = device.createShaderModule({
            label: "Cell shader",
            code: `
                struct VertexInput {
                    @location(0) pos: vec2f,
                    @builtin(instance_index) instance: u32,
                };

                struct VertexOutput {
                    @builtin(position) pos: vec4f,
                    @location(0) cell: vec2f,
                };

                @group(0) @binding(0) var<uniform> grid: vec2f;
                @group(0) @binding(1) var<storage> cellState: array<u32>;

                @vertex
                fn vertexMain(input: VertexInput) -> VertexOutput {
                    
                    let i = f32(input.instance); // Save the instance_index as a float
                    
                    let state = f32(cellState[input.instance]);
                    let cell = vec2f(i%grid.x, floor(i/grid.x)); // Cell(1,1) in the image above
                    let cellOffset = (cell / grid)*2; // Compute the offset to cell

                    let gridPos = ((state*input.pos+1)/grid)-1 + cellOffset;

                    var output: VertexOutput;
                    output.pos = vec4f(gridPos, 0, 1); // (X, Y, Z, W)
                    output.cell = cell;

                    return output;
                }

                @fragment
                fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
                    return vec4f(input.cell/grid, 1, 1);
                }
            `
        });

        // define the shader program
        const cellPipeline = device.createRenderPipeline({
            label: "Cell pipeline",
            layout: "auto",
            vertex: {
                module: cellShaderModule,
                entryPoint: "vertexMain",
                buffers: [vertexBufferLayout]
            },
            fragment: {
                module: cellShaderModule,
                entryPoint: "fragmentMain",
                targets: [{
                format: canvasFormat
                }]
            }
        });

        const GRID_SIZE = 32;

        // Create a uniform buffer that describes the grid.
        const uniformArray = new Float32Array([GRID_SIZE, GRID_SIZE]);
        const uniformBuffer = device.createBuffer({
            label: "Grid Uniforms",
            size: uniformArray.byteLength,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(uniformBuffer, 0, uniformArray);

        // Create an array representing the active state of each cell.
        const cellStateArray = new Uint32Array(GRID_SIZE * GRID_SIZE);

        // Create a storage buffer to hold the cell state.
        const cellStateStorage = device.createBuffer({
            label: "Cell State",
            size: cellStateArray.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
        });

        // Mark every third cell of the grid as active.
        for (let i = 0; i < cellStateArray.length; i += 3) {
            cellStateArray[i] = 1;
        }
        device.queue.writeBuffer(cellStateStorage, 0, cellStateArray);

        const bindGroup = device.createBindGroup({
            label: "Cell renderer bind group",
            layout: cellPipeline.getBindGroupLayout(0),
            entries: [
                {
                    binding: 0,
                    resource: { buffer: uniformBuffer }
                },{
                    binding: 1,
                    resource: { buffer: cellStateStorage }
                }
            ],
        });


        // encoder to send commands to the WebGPU context
        const encoder = device.createCommandEncoder();

        // main loop
        const pass = encoder.beginRenderPass({
            colorAttachments: [{
                view: context.getCurrentTexture().createView(),
                loadOp: "clear",
                clearValue: {r: 0.69, g:0.69, b:0.69, a:1.0},
                storeOp: "store",
            }]
        });


        pass.setPipeline(cellPipeline); // kinda like the shader program
        pass.setVertexBuffer(0, vertexBuffer);
        pass.setBindGroup(0, bindGroup);
        pass.draw(vertices.length / 2, GRID_SIZE * GRID_SIZE); // 6 vertices


        pass.end();

        const commandBuffer = encoder.finish();
        device.queue.submit([commandBuffer]);

        // Finish the command buffer and immediately submit it.
        // device.queue.submit([encoder.finish()]);



    
    </script>

</body>
</html>